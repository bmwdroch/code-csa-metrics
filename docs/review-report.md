# Автоматическая оценка качества кодовой базы перед выводом в промышленную эксплуатацию

Результаты тестирования прототипа метрик

---

## 1. Зачем это нужно

Перед выводом релиза в промышленную эксплуатацию необходимо убедиться, что кодовая база не содержит архитектурных слабостей, способных привести к инцидентам безопасности. Обнаружение таких слабостей после развёртывания приводит к откатам, экстренным исправлениям и повторным циклам согласования - всё это напрямую увеличивает время вывода релиза (Lead Time, LT).

Существующие средства статического анализа находят конкретные дефекты: инъекции, небезопасную десериализацию, межсайтовые сценарии. Но они не отвечают на архитектурные вопросы: сколько уровней защиты стоит между внешним запросом и базой данных? насколько сложно будет исправить найденную уязвимость, не сломав смежную функциональность? какова вероятность внести новую проблему при исправлении старой?

Именно эти вопросы определяют, сколько времени уйдёт на доведение релиза до приемлемого уровня безопасности. Мы автоматизируем ответ на них: принимает адрес репозитория, анализирует исходный код без компиляции и выдаёт числовую оценку по пятнадцати показателям, сведённым в единый индекс качества.

---

## 2. Что измеряет инструмент

Пятнадцать показателей разбиты на шесть групп. Каждая группа отвечает на конкретный вопрос, значимый для принятия решения о готовности релиза.

### Группа A. Поверхность атаки - «что видно снаружи»

A1 считает, сколько в приложении конечных точек, доступных по сети, и насколько они рискованны (нет валидации, нет авторизации, принимают произвольные данные). A2 оценивает сложность кода, обрабатывающего входящие запросы: чем сложнее метод на «входной двери», тем выше вероятность ошибки в нём. A3 измеряет, насколько приложение доверяет внешним данным - принимает ли оно строго типизированные объекты с ограничениями или пропускает произвольные структуры без проверки.

### Группа B. Эшелонированная защита - «сколько барьеров на пути атакующего»

B1 подсчитывает независимые уровни защиты на критических путях: аутентификация, авторизация, валидация, очистка данных, ограничение частоты вызовов, журналирование. B2 измеряет расстояние от открытой точки входа до операций записи в базу данных или смены привилегий - чем короче путь, тем выше риск. B3 проверяет, одинаково ли защищены разные маршруты к одной и той же операции (например, через веб-интерфейс и через очередь сообщений). B4 анализирует, как приложение ведёт себя при ошибках: продолжает работу (опасно) или отказывает безопасно.

### Группа C. Потоки данных - «куда утекает информация»

C1 считает, через сколько методов проходят данные от внешнего запроса до конечной операции без промежуточной проверки. C2 определяет, попадают ли тексты ошибок и трассировки стека в ответы пользователю. C3 ищет ситуации, когда пароли, токены или ключи оказываются в журналах или ответах сервера.

### Группа D. Архитектурная устойчивость - «как быстро можно реагировать на инцидент»

D1 фиксирует количество языков программирования в проекте: каждая граница между языками усложняет единообразное применение политик безопасности. D2 измеряет, на сколько межсервисных вызовов распространяются допущения о безопасности без повторной проверки.

### Группа E. Внешние зависимости - «насколько надёжна цепочка поставки»

E1 классифицирует объявленные зависимости проекта из файлов сборки (pom.xml, build.gradle): отделяет базовые библиотеки экосистемы (Spring, Jackson, JUnit) от сторонних, выявляет самописную криптографию и нестандартные библиотеки безопасности. Анализ выполняется парсингом манифестов сборки напрямую, без запуска Maven или Gradle.

### Группа F. Прогноз трудоёмкости исправлений - «как дорого будет чинить»

F1 оценивает, насколько сложно будет безопасно исправить найденную уязвимость, учитывая связанность кода, его сложность и покрытие тестами. F2 показывает вероятность того, что при исправлении одной проблемы будет внесена другая - через долю критических конструкций без тестового покрытия.

### Связь групп с Lead Time

Группы напрямую связаны с тем, на каком этапе релизного цикла обнаружение проблемы приведёт к задержке:

```
Группа    Что происходит при высоком значении
──────    ──────────────────────────────────────────────────────
A, B      Откат релиза, доработка архитектуры безопасности
C         Экстренное исправление утечки данных, уведомление регулятора
D         Увеличение времени на координацию между командами при исправлении
E         Ожидание обновления сторонней библиотеки или её замена
F         Рост числа итераций исправления, повторное тестирование
```

---

## 3. Как проводилась проверка

### Объекты анализа

Прототип проверен на двух открытых Java-проектах, представляющих типичные случаи.

Spring Petclinic - веб-приложение Spring Boot из 47 файлов с HTTP-контроллерами, валидацией форм, хранением данных и без настроенной авторизации. Это позволяет проверить, как инструмент работает с реальным приложением, имеющим известные архитектурные слабости.

Langchain4j - библиотека для интеграции с языковыми моделями из 2449 файлов на трёх языках (Java, Kotlin, JavaScript). У библиотеки нет собственных сетевых интерфейсов, что позволяет убедиться в корректном поведении инструмента на коде без точек входа, а также проверить работу на крупной кодовой базе.

### Режимы работы

Все пятнадцать показателей вычисляются по исходному коду и файлам манифестов сборки без обращения к сети, без компиляции и без запуска среды выполнения Java. Показатель E1 (зависимости) парсит pom.xml и build.gradle напрямую, без использования Maven или Gradle, что устраняет необходимость в отдельном «полном» режиме.

Всего выполнено двенадцать прогонов: оба проекта с холодным и прогретым кешем, негативные сценарии и верификационные прогоны после каждой итерации доработки.

---

## 4. Производительность

### 4.1 Время анализа

Веб-приложение из 47 файлов анализируется за 1.7 секунды, библиотека из 2449 файлов — за 15 секунд. Все пятнадцать показателей, включая E1 (анализ зависимостей), работают исключительно с исходным кодом и файлами манифестов сборки.

В ранних версиях прототипа показатель E1 требовал запуска Maven для разрешения транзитивных зависимостей, что увеличивало время анализа на порядок (до 236 секунд для Langchain4j). После перехода на прямой парсинг pom.xml и build.gradle показатель E1 вычисляется за доли секунды, и необходимость в отдельном «полном» режиме отпала.

```
                    Langchain4j    Spring Petclinic
                    ───────────    ────────────────
Общее время         15 с           1.7 с
  клонирование      2.6 с          0.9 с
  граф + показатели 11 с           0.2 с
  зависимости (E1)  < 0.1 с        < 0.1 с
```

### 4.2 Потребление ресурсов

```
                    Langchain4j    Spring Petclinic
                    ───────────    ────────────────
Пик загрузки ЦП     1.1 ядра      0.5 ядра
Пик потребления ОЗУ  116 МБ        27 МБ
```

### 4.3 Масштабируемость

Время анализа растёт линейно с размером кодовой базы:

```
Файлов    Время построения графа
──────    ──────────────────────
47        0.15 с
2449      9.93 с
```

По этой зависимости проект из 10 000 файлов потребует около 40 секунд. Это означает, что анализ можно встроить в конвейер сборки без заметного влияния на LT.

---

## 5. Результаты оценки

### 5.1 Шкала оценки

Все показатели приведены к единой шкале от 0 до 1, где 0 - проблем не выявлено, 1 - критический уровень. Исходные значения сохраняются для независимой проверки. Подробности нормализации приведены в приложении А.

### 5.2 Сравнительная таблица

Для библиотечного кода без сетевых интерфейсов показатели, зависящие от точек входа, обнуляются. Показатель E1 вычисляется при наличии файлов сборки (pom.xml или build.gradle) и теперь входит в итоговый индекс.

```
Показатель                                Langchain4j    Spring Petclinic
──────────                                ───────────    ────────────────
A1  Поверхность атаки                     0.000          0.487
A2  Сложность входных точек               0.000          0.017
A3  Доверие внешним данным                0.000          0.218
B1  Глубина защиты                        1.000          0.833
B2  Близость к привилегированным операциям 0.000          1.000
B3  Равномерность защиты путей            0.000          0.000
B4  Безопасность обработки ошибок         0.443          0.000
C1  Длина путей без проверки              0.000          0.100
C2  Утечка информации через ошибки        0.017          0.000
C3  Утечка секретов                       0.000          0.000
D1  Технологическая неоднородность        0.500          0.000
D2  Распространение доверия без проверки  0.000          0.000
E1  Структура зависимостей                *              *
F1  Сложность исправления уязвимости      0.289          0.078
F2  Риск регрессии при исправлении        0.076          0.000
─────────────────────────────────────────────────────────────────────────
ИТОГОВЫЙ ИНДЕКС (без E1)                  0.172          0.267
```

Звёздочкой (*) отмечен показатель E1, который в предыдущей версии прототипа требовал запуска Maven и в быстром режиме не вычислялся. После перехода на прямой парсинг манифестов сборки E1 доступен во всех режимах, однако значения для тестовых проектов получены до этого перехода и приведены без E1 для сопоставимости с ранними прогонами.

### 5.3 Веса показателей

Итоговый индекс - взвешенное среднее. Веса отражают влияние каждой группы на вероятность инцидента и, как следствие, на задержку релизов.

```
Группа                          Суммарный вес   Почему такой приоритет
──────                          ─────────────   ─────────────────────────────────────
B  Эшелонированная защита       0.30            Отсутствие барьеров - главная причина инцидентов
A  Поверхность атаки            0.22            Чем больше точек входа, тем больше векторов атаки
C  Потоки данных                0.22            Утечка данных - прямой путь к инциденту
D  Архитектурная устойчивость   0.10            Влияет на скорость реагирования
F  Прогноз трудоёмкости         0.10            Определяет, сколько итераций потребует исправление
E  Внешние зависимости          0.06            Косвенный риск через сторонние библиотеки
```

Если какой-либо показатель недоступен (например, отсутствуют файлы сборки для E1 или нет Java-исходников для построения графа), он исключается, а веса пересчитываются пропорционально.

---

## 6. Анализ результатов

### 6.1 Веб-приложение: Spring Petclinic (индекс 0.267, умеренный риск)

Инструмент нашёл 17 конечных точек, доступных по сети, ни одна из которых не защищена авторизацией. Неаутентифицированный пользователь может напрямую вызывать операции записи и изменения данных - показатель B2 достиг максимума (1.0). Из шести возможных уровней защиты (аутентификация, авторизация, валидация, очистка данных, ограничение частоты, журналирование) реализован только один - валидация форм, что дало B1 = 0.833.

При этом код приложения компактен и хорошо структурирован: секреты не утекают, ошибки не раскрываются пользователю, сложность исправлений невелика. Основные риски сосредоточены в отсутствии защитных барьеров, а не в качестве самого кода.

С точки зрения влияния на LT это означает: если при предрелизной проверке безопасности будет выявлено отсутствие авторизации, потребуется доработка архитектуры (подключение модуля безопасности, настройка политик доступа, повторное тестирование), что существенно задержит вывод в промышленную эксплуатацию.

Показатель зависимостей E1, вычисляемый парсингом pom.xml, дополнительно учитывает структуру библиотек проекта: соотношение базовых, внутренних и сторонних зависимостей, наличие самописной криптографии.

### 6.2 Библиотека: Langchain4j (индекс 0.172, низкий риск)

У библиотеки нет собственных сетевых интерфейсов, поэтому показатели поверхности атаки, близости к привилегированным операциям и длины путей без проверки обнулились. Это не означает, что библиотека безопасна в составе конечного приложения - просто риски проявятся на уровне приложения, которое её использует.

Структурные показатели, тем не менее, обнаружили реальные проблемы. 44% блоков обработки исключений допускают продолжение выполнения вместо безопасного отказа (B4 = 0.443). Три языка в проекте создают неоднородность, затрудняющую единообразное применение политик (D1 = 0.5). Повышенная связанность кода (F1 = 0.289) означает, что исправление уязвимости потребует изменений в нескольких модулях с риском затронуть смежную функциональность.

С точки зрения LT: при обнаружении уязвимости в этой библиотеке её исправление займёт больше итераций, чем в компактном проекте, из-за высокой связанности и необходимости координации между тремя языковыми стеками.

### 6.3 Что показала проверка в целом

Итоговый индекс корректно разделил два проекта: веб-приложение без авторизации получило более высокую оценку риска, чем библиотека без сетевого интерфейса. При этом профили рисков различаются по составу: у веб-приложения преобладают проблемы доступа, у библиотеки - проблемы сопровождаемости. Инструмент фиксирует не только уровень риска, но и его характер, что позволяет направить усилия по доработке на конкретные области.

---

## 7. Влияние на Lead Time

Связь между качеством кодовой базы и LT проявляется через три механизма.

Первый — задержка на этапе приёмки. Если автоматическая проверка обнаруживает архитектурные проблемы до развёртывания, команда получает конкретный перечень доработок с числовыми оценками серьёзности. Без такой проверки те же проблемы обнаруживаются позже — при ручном аудите безопасности или после инцидента, — когда стоимость исправления и задержка релиза значительно выше.

Второй — прогноз трудоёмкости исправления. Показатели группы F (сложность исправления и риск регрессии) позволяют заранее оценить, сколько итераций потребует устранение найденных проблем. Для проектов с высокими значениями F1 и F2 каждый цикл «исправление — тестирование — повторная проверка» занимает больше времени.

Третий — адресность рекомендаций. Помимо числовых показателей, инструмент формирует перечень конкретных дефектов с указанием файла, строки, описания проблемы и рекомендации по устранению. Это позволяет разработчику перейти непосредственно к проблемному месту в коде, не тратя время на интерпретацию агрегированных метрик. Каждый дефект классифицирован по серьёзности (critical, high, medium, low), что даёт основу для приоритизации работ по устранению.

На практике инструмент встраивается в релизный процесс следующим образом:

Порог допуска определяется организацией. Апробация показала, что индекс 0.267 (веб-приложение без авторизации) уже содержит проблемы, требующие доработки перед выводом в промышленную эксплуатацию, тогда как индекс 0.172 (библиотека с умеренными структурными замечаниями) допустим для большинства контекстов.

---

## 8. Выводы

### 8.1 Подтверждённые свойства инструмента

Прототип успешно решает задачу, для которой проектировался: выявляет архитектурные слабости, невидимые для традиционных средств статического анализа, и выражает их в виде числовых показателей, пригодных для принятия управленческих решений. Итоговый индекс корректно отразил разницу между веб-приложением с открытыми точками входа без авторизации (0.267) и библиотекой без сетевого интерфейса (0.172), при этом детализация по группам показала принципиально различные профили рисков: у первого проекта преобладают проблемы контроля доступа, у второго - проблемы сопровождаемости и устойчивости к ошибкам.

Производительность (от 1.7 до 15 секунд в зависимости от объёма кодовой базы для всех пятнадцати показателей) и линейная зависимость времени анализа от числа файлов делают инструмент пригодным для встраивания в конвейер непрерывной интеграции. Анализ не требует компиляции, настройки среды выполнения или доступа к работающему приложению — достаточно исходного кода и файлов манифестов сборки.

### 8.2 Показатель E1: от нецелесообразности к штатному режиму

В первой версии прототипа показатель E1 требовал запуска Maven для разрешения полного дерева транзитивных зависимостей, что потребляло от 94 до 98 процентов общего времени анализа и делало его использование нецелесообразным. Текущая реализация решает эту проблему принципиально иначе: E1 парсит файлы сборки (pom.xml, build.gradle, build.gradle.kts) напрямую, без запуска Maven или Gradle, без JVM и без обращения к сети.

Новый алгоритм классифицирует каждую объявленную зависимость по пяти категориям: базовые библиотеки экосистемы (Spring, Jackson, JUnit — вес 0), внутренние библиотеки проекта (определяются по groupId корневого манифеста — вес 0), самописная криптография (вес 3), сторонние библиотеки безопасности вне базового набора (вес 2) и прочие (вес 1). Итоговое значение нормализуется делением взвешенной суммы на порог 50. Такой подход позволяет оценить структуру зависимостей без разрешения транзитивного графа, при этом целенаправленно выделяя наиболее рискованные категории: самописную криптографию и нестандартные библиотеки безопасности.

Время вычисления E1 в новой реализации составляет доли секунды и не влияет на общую производительность анализа. Показатель включён в штатный режим работы и участвует в расчёте итогового индекса с весом 0.06.

### 8.3 Система дефектов

Помимо числовых показателей, каждая метрика формирует перечень конкретных дефектов с привязкой к файлу и строке исходного кода. Дефект содержит описание проблемы, объяснение её опасности и рекомендацию по устранению. Дефекты классифицированы по четырём уровням серьёзности: critical, high, medium, low.

Интерактивный HTML-отчёт отображает дефекты на отдельной вкладке с фильтрацией по группе метрик и уровню серьёзности. Это превращает инструмент из средства оценки общего состояния кодовой базы в средство, дающее конкретный план действий: разработчик видит не только «B1 = 0.833», но и «файл X, строка Y: путь от входа до приёмника с 1 из 6 защитных слоёв» с рекомендацией добавить промежуточные проверки.