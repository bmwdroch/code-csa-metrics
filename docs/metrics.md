## Группа A: Поверхность атаки и входные точки

> Что видит атакующий снаружи? 

---

### A1. Открытость поверхности атаки (ASE)

Количество входных точек × риски по каждой.

Алгоритм:
- Подсчёт входных точек: `@RequestMapping`, `@KafkaListener`, `@Consumer`, публичные REST-маршруты API.
- Повышающие веса:
  - Метод принимает `String`, `Map`, `Object` (нетипизированные данные - риск инъекций).
  - Нет аннотаций авторизации (`@PreAuthorize`, `@Secured`).
  - Нет явной валидации входных параметров.
- `ASE = Σ(base_weight × risk_multipliers)` по всем точкам входа.

AppSec смотрит дефекты, Sonar качество, мы риски из-за количества

---

### A2. Индекс взрывной сложности (ECI)

Сложность кода, умноженная на близость к внешнему входу. Метод со сложностью 20 глубоко внутри - плохо. Метод со сложностью 20, принимающий HTTP Request - критично.

Алгоритм:
- Строим граф вызовов.
- Помечаем точки входа (API, очереди, слушатели).
- Для каждого метода: `ECI = Cognitive_Complexity / (Distance_to_Entry + 1)`.

Суть в том, что затруднена отладка и т.п., когда методы зарыты. Сложность кода тут имеется ввиду как у Sonar. Тут что-то интересное + не повторяемся.

---

### A3. Входная энтропия (IET)

Количественная мера того, насколько доверчив код к внешним данным. Метод, принимающий `Object`, допускает бесконечное множество входов. Метод с `@Valid CreateUserRequest` - конечное, контролируемое.

Алгоритм:
- Для каждого публичного метода, принимающего внешние данные:
  - Классификация типов параметров:
    - `String`, `Object`, `Map<String,Object>`, `JsonNode` → высокая энтропия
    - `byte[]`, `InputStream` → очень высокая (бинарные данные без структуры)
    - DTO с `@NotNull`, `@Size`, `@Pattern` → низкая энтропия
    - Enum, boolean, bounded int → минимальная
  - Наличие валидации в теле метода снижает результирующую энтропию.
- `IET_system = weighted_avg(IET по точкам входа)`, вес = степень открытости (public API > internal).

Энтропия звучит красиво и сложно, по сути можно и проще делать. Суть в том, чтобы дать вес той или иной валидации. Другие сканеры просто показывают да/нет.

---

## Группа B: Глубина обороны

> Сколько стен нужно пробить атакующему? 

---

### B1. Глубина эшелонированной защиты (IDS)

Количественная оценка принципа Defense-in-Depth - сколько независимых слоёв защиты стоит на каждом критическом пути от входа до чувствительной операции. Система сильна настолько, насколько силён слабейший путь.

Алгоритм:
- Граф вызовов от каждой точки входа до каждого приёмника (БД, ФС, внешний API, ответ клиенту).
- На каждом пути классифицируем защитные слои:
  - Аутентификация (Spring Security filter, проверка токена)
  - Авторизация (`@PreAuthorize`, `hasRole`, проверка принадлежности ресурса)
  - Валидация (`@Valid`, собственные валидаторы)
  - Санитизация (escape, encode, `HtmlUtils.htmlEscape`)
  - Ограничение частоты (`@RateLimiter`, собственные фильтры)
  - Аудит-логирование (фиксация событий безопасности)
- `IDS_path = уникальные_категории_защиты / 6`
- `IDS_system = min(IDS_path)` по всем критическим путям.

---

### B2. Индекс близости к привилегиям (PPI)

Расстояние от неаутентифицированной точки входа до привилегированной операции в графе вызовов. 

Алгоритм:
- Идентификация привилегированных операций: запись/удаление в БД, изменение прав, доступ к ПДн, финансовые транзакции.
- Идентификация публичных точек входа без авторизации.
- BFS по граф вызовов: минимальное количество переходов от публичного входа до привилегированной операции.
- `PPI = 1 / (min_distance + 1)` - чем короче путь, тем выше риск.

---

### B3. Паритет защиты по путям (MPSP)

Одна и та же чувствительная операция часто доступна через несколько входных путей - REST API, Kafka, gRPC, job, internal call. Все ли пути защищены одинаково?

Алгоритм:
- Для каждого метода-приёмника (операция с БД, ФС, внешний API) находим всех вызывающих через обратный граф вызовов.
- Трассируем каждую цепочку вызовов до точки входа.
- Для каждого пути оцениваем меры безопасности (auth, authz, validation).
- `MPSP_operation = min(security_score_path) / max(security_score_path)`
  - 1.0 = все пути защищены одинаково (OK)
  - < 1.0 = есть путь слабее остальных (РИСК)
- `MPSP_system = min(MPSP_operation)` - самая слабая пара.

То есть, если есть критичный метод, а к нему ведут разные пути, то светим критичный путь.

---

### B4. Оценка безопасного отказа (FSS)

Что происходит, когда проверка безопасности падает с ошибкой? Пропускает или нет?

Алгоритм:
- Поиск всех catch-блоков, оборачивающих код, связанный с безопасностью
- Классификация поведения после catch:
  - Fail-closed (безопасно): re-throw, return error, deny access.
  - Fail-open (критично): continue execution, return true/success, пустой catch.
  - Ambiguous: log + continue - зависит от контекста.
- `FSS = (fail_closed_catches) / (all_security_catches)`
- Дополнительно: пустые catch-блоки (`catch (Exception e) {}`) в путях, связанных с безопасностью = отдельное критическое предупреждение.

---

## Группа C: Потоки данных и утечки

> Куда текут данные? Куда утекают секреты? Что видит атакующий через ошибки?

---

### C1. Сложность пути заражённых данных (TPC)

Насколько глубоко данные уходят без валидации

Алгоритм:
- Статический анализ граф вызовов от контроллера до приёмника-методов.
- Подсчёт количества промежуточных вызовов без валидации/санитизации.
- `TPC = средняя/максимальная глубина грязного пути`

---

### C2. Индекс прозрачности ошибок (ETI)

Куда уходит ошибка?

Алгоритм:
- AST-анализ всех catch-блоков / обработчиков ошибок.
- Трассировка: куда уходит exception?
  - `log only` → OK
  - `response body / HTTP response` → УТЕЧКА
  - `swallowed` (поглощён - пустой catch) → РИСК
- Паттерны утечки: `e.getMessage()` → response, конкатенация имён таблиц/путей в ответе, `printStackTrace()`.
- `ETI = (catch-блоки с утечкой) / (общее количество catch-блоков)`

---

### C3. Анализ потоков секретов (SFA)

Уходят ли секреты в код? Неявно.

Алгоритм:
- Идентификация источников: переменные `password/token/secret/apiKey/creditCard`, аннотации `@Sensitive`, типы `SecretString`.
- граф потоков данных от каждого источника.
- Обнаружение точек утечки утечки:
  - Логирование: `log.info("pwd=" + password)` → CRITICAL
  - Сериализация: `objectMapper.writeValueAsString(userWithPassword)` → HIGH
  - HTTP Response: `return entity` (если содержит secret-поле) → HIGH
  - Кэширование: `redis.set(key, objectWithSecrets)` → MEDIUM
- `SFA = (пути секрет → утечка) / (все потоки с секретами)`

SS ищет сами секреты, а не их путь.

---

## Группа D: Архитектурная устойчивость

> Насколько код готов к быстрому и безопасному изменению при инцидентах?

---
### D1. Дрейф атак на стыках технологий (PAD)

Риск от смешения языков, спецификаций и сред выполнения

Алгоритм:
- Подсчёт технологических границ: Java + Node, Python + Go и т.д.
- Оценка несогласованности security policy между ними (Java-сервис валидирует, Node-прослойка - нет).
- `PAD = количество_границ × вес_разрыва_политики`

---

### D2. Глубина распространения цепочки доверия (TCPD)

В микросервисах аутентификация проверяется на входе, а дальше - сервисы доверяют друг другу. Через сколько переходов безопасность путешествует без перепроверки?

Алгоритм:
- Для каждого запроса: на каком переходе последний раз проверяется подлинность?
- `TCPD = max(hops_after_last_validation)` по всем путям.

---

## Группа E: Рассинхрон и расхождение

---

### E1. Риск зависимостей с открытым кодом (OSDR)

Суть: Не просто есть ли CVE (это SCA), а оценка устойчивости и живучести экосистемы зависимостей.

Алгоритм:
- Доля транзитивных зависимостей с открытым кодом.
- Взвешивание по: лицензия, активность репозитория (последний коммит), количество сопровождающих.
- Количество осиротевших библиотек (без обновлений > 1 года).
- Фактор автобуса: зависимости с 1-2 сопровождающими.

Связь с LT: Высокий OSDR → больше согласований при обновлениях → рост LT. Мёртвые зависимости → необходимость создавать ответвление при уязвимости → значительный MTTR.

---

## Группа F: Предсказание и прогноз

> Не есть ли проблема сейчас, а что будет, когда проблема возникнет.

---

### F1. Предиктор сложности исправления уязвимости (VFCP)

Эта метрика агрегирует характеристики кода (сложность, связность, покрытие тестами, дубли, абстракции) в единый предиктор. Вместо 6 отдельных низкоуровневых метрик сонара - одна

Алгоритм:
- Для каждого класса/модуля:
  - `coupling` = afferent + efferent coupling (входящие + исходящие зависимости)
  - `complexity` = средняя когнитивная сложность методов
  - `test_coverage` = покрытие тестами (branch coverage)
  - `duplicate_factor` = LDRI модуля (логические дубли)
  - `abstraction_level` = AAI модуля (абстракции и атомарность)

---

### F2. Вероятность регрессии безопасности (SRP)

Мутационное тестирование, только в контексте КБ.

Алгоритм:
- Выделяем конструкции, связанные с безопасностью через AST:
  - Проверки авторизации (`@PreAuthorize`, `if hasRole`, `SecurityContext`)
  - Валидация (`@Valid`, `Pattern.matches`, `if isEmpty`)
  - Криптография (`encrypt`, `hash`, `sign`)
  - Санитизация (`escape`, `encode`, `sanitize`)
- Для каждой конструкции:
  - Есть ли тест, непосредственно проверяющий этот инвариант безопасности?
  - Если конструкцию удалить/инвертировать - упадёт ли тест?
- `SRP = (конструкции безопасности без тестового покрытия) / (все конструкции безопасности)`

---

## Мета-уровень: Композитная модель

---

### M1. Граф топологии безопасности - автоматическая модель угроз из кода

Представление кодовой базы как графа безопасности с нашими теоретико-графовыми метриками. По сути просто рисуем метрики на каждом узле.

![[security-topology.svg]]